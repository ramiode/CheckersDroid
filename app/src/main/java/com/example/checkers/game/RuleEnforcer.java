package com.example.checkers.game;

import com.example.checkers.game.models.GameBoardModel;
import com.example.checkers.game.models.actions.Action;
import com.example.checkers.game.models.actions.JumpAction;
import com.example.checkers.game.models.actions.MoveAction;
import com.example.checkers.utils.AppConstants;

import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

/**
 * Used statically throughout the program to check if actions adhere to the rules of checkers.
 *
 * @author Ramiar Odendaal
 */
public class RuleEnforcer {
    private static final int LEFT_DIAGONAL = 7;
    private static final int RIGHT_DIAGONAL = 9;

    /**
     * Used to check a generic action. Calls appropriate helper methods.
     *
     * @param action the action to check
     * @param state the current state of the game
     * @return true only if the action is valid
     */
    public static boolean isActionValid(final Action action, final GameState state) {
        if(action instanceof MoveAction){
            return isMoveValid((MoveAction) action, state.getBoard(), false);
        }
        else if(action instanceof JumpAction){
            return isJumpValid((JumpAction) action, state);
        }
        else{
            return false;
        }
    }

    /**
     * Checks if the given JumpAction is valid based on the current state.
     *
     * @param jump the JumpAction to check
     * @param state the state of the game
     * @return true only if the jump is valid
     */
    private static boolean isJumpValid(JumpAction jump, GameState state){
        List<Integer> positions = jump.getPositions();

        MoveAction firstJump = new MoveAction(jump.getStone().getPosition(), positions.get(0), jump.getActingPlayer(), jump.getStone());
        boolean isMoveValid = isMoveValid(firstJump, state.getBoard(), true);

        if(positions.size() == 1){
            return isMoveValid;
        }
        else{
            //TODO: Rework
            boolean areAllMovesValid = IntStream.range(1, positions.size())
                    .mapToObj(i -> new MoveAction(positions.get(i - 1), positions.get(i), jump.getActingPlayer(), jump.getStone()))
                    .allMatch(move -> isMoveValid(move, state.getBoard(), true));

            return isMoveValid && areAllMovesValid;
        }
    }

    /**
     * Checks if the given MoveAction is valid and doesn't break the rules of checkers.
     *
     * @param move the move action to check
     * @param model the current state of the board
     * @param isJump set to true if this move is generated by a jump
     * @return true only if the move is valid
     */
    private static boolean isMoveValid(MoveAction move, GameBoardModel model, boolean isJump) {
        int stepDistance = move.to - move.from;
        int multiplier = isJump ? 2 : 1;

        if(isOutOfBounds(move.to)){
            return false;
        } else if (!AppConstants.BOARD_COLOR[move.to].equals("BLACK")) {
            return false;
        } else if(model.isPositionOccupied(move.to)){
            return false;
        } else if(!isOnDiagonal(move.from, move.to)){
            return false;
        } else if (!(Math.abs(stepDistance) == LEFT_DIAGONAL * multiplier || Math.abs(stepDistance) == RIGHT_DIAGONAL * multiplier)) {
            return false;
        } else if(Arrays.stream(move.getStone().getDirections()).noneMatch(e -> e * multiplier == stepDistance)){
            return false;
        }
        return true;
    }

    /**
     * Checks if the starting position and final position are diagonally aligned.
     *
     * @param from the starting position
     * @param to the final position
     * @return true only if the move is diagonal
     */
    public static boolean isOnDiagonal(int from, int to) {
        int fromRow = AppConstants.ROW[from];
        int toRow = AppConstants.ROW[to];

        int fromCol = AppConstants.COL[from];
        int toCol = AppConstants.COL[to];

        // For diagonal moves, row and col must each change by exactly 1 (for move) or 2 (for jump)
        int rowDiff = Math.abs(toRow - fromRow);
        int colDiff = Math.abs(toCol - fromCol);

        return rowDiff == colDiff; // true if still on a diagonal
    }

    /**
     * Checks if the position is out of bounds, i.e. not contained in the board.
     *
     * @param position the position to check
     * @return true only if position > 63 and < 0
     */
    public static boolean isOutOfBounds(int position){
        if(position > 63){
            return true;
        }
        else if(position < 0){
            return true;
        }
        else{
            return false;
        }
    }
}
